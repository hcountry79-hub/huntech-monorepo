name: HUNTECH CDN + Domain (ONE FILE, self-healing)

on:
  workflow_dispatch:
    inputs:
      dist_id:
        description: "Optional: CloudFront Distribution ID (leave blank to auto-discover/create)"
        required: false
        default: ""

jobs:
  cdn_domain:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: us-east-1
      ACCOUNT_ID: "382773571217"
      ROLE_TO_ASSUME: arn:aws:iam::382773571217:role/HUNTECH-CICD
      # Private web bucket from your core foundation
      WEB_BUCKET: huntech-web-382773571217-us-east-1-core
      # Domain & zone
      CORE_FQDN: core.huntechusa.com
      APEX_DOMAIN: huntechusa.com
      CLOUDFRONT_ZONE_ID: Z2FDTNDATAQYW2  # Route 53 alias zone id for CloudFront (global constant)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure jq
        run: |
          set -e
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

      - name: Ensure minimal permissions for this run (ACM/Route53/CloudFront/S3)
        run: |
          set -e
          POLICY=$(jq -n '{
            Version:"2012-10-17",
            Statement:[
              {Sid:"ACM",Effect:"Allow",Action:[
                "acm:RequestCertificate","acm:DescribeCertificate","acm:ListCertificates","acm:AddTagsToCertificate","acm:DeleteCertificate"
              ],Resource:"*"},
              {Sid:"R53",Effect:"Allow",Action:[
                "route53:ListHostedZonesByName","route53:GetHostedZone","route53:ListResourceRecordSets","route53:ChangeResourceRecordSets"
              ],Resource:"*"},
              {Sid:"CF",Effect:"Allow",Action:[
                "cloudfront:CreateDistribution","cloudfront:UpdateDistribution","cloudfront:GetDistribution",
                "cloudfront:GetDistributionConfig","cloudfront:ListDistributions","cloudfront:CreateInvalidation",
                "cloudfront:CreateOriginAccessControl","cloudfront:ListOriginAccessControls","cloudfront:GetOriginAccessControl"
              ],Resource:"*"},
              {Sid:"S3Policy",Effect:"Allow",Action:[
                "s3:GetBucketPolicy","s3:PutBucketPolicy","s3:GetObject","s3:PutObject","s3:DeleteObject"
              ],Resource:[
                "arn:aws:s3:::${WEB_BUCKET}",
                "arn:aws:s3:::${WEB_BUCKET}/*"
              ]}
            ]
          }')
          printf '%s' "$POLICY" > /tmp/HUNTECH-WebDNS-Perms.json
          aws iam put-role-policy \
            --role-name HUNTECH-CICD \
            --policy-name HUNTECH-WebDNS-Perms \
            --policy-document file:///tmp/HUNTECH-WebDNS-Perms.json || true

      - name: Resolve Route53 Hosted Zone for apex
        id: hz
        run: |
          set -e
          HZ_ID=$(aws route53 list-hosted-zones-by-name --dns-name "${APEX_DOMAIN}" \
            --query "HostedZones[?Name=='${APEX_DOMAIN}.'].Id" --output text | sed 's#/hostedzone/##')
          [ -z "$HZ_ID" -o "$HZ_ID" = "None" ] && { echo "Hosted zone ${APEX_DOMAIN} not found"; exit 1; }
          echo "HZ_ID=$HZ_ID" >> $GITHUB_ENV
          echo "HostedZoneId: $HZ_ID"

      - name: Resolve or create OAC (sigv4, always)
        id: oac
        run: |
          set -e
          OAC_NAME="oac-${WEB_BUCKET}"
          OAC_ID=$(aws cloudfront list-origin-access-controls \
            --query "OriginAccessControlList.Items[?Name=='${OAC_NAME}'].Id" \
            --output text 2>/dev/null || true)
          if [ -z "$OAC_ID" ] || [ "$OAC_ID" = "None" ]; then
            CFG=$(jq -n --arg name "$OAC_NAME" --arg desc "OAC for $WEB_BUCKET" '{
              Name:$name, Description:$desc,
              SigningProtocol:"sigv4", SigningBehavior:"always",
              OriginAccessControlOriginType:"s3"
            }')
            OAC_ID=$(aws cloudfront create-origin-access-control \
              --origin-access-control-config "$CFG" \
              --query "OriginAccessControl.Id" --output text)
            echo "Created OAC: $OAC_ID"
          else
            echo "Using OAC: $OAC_ID"
          fi
          echo "OAC_ID=$OAC_ID" >> $GITHUB_ENV

      - name: Resolve or create CloudFront distribution (input → existing → create)
        id: dist
        env:
          DIST_ID_INPUT: ${{ github.event.inputs.dist_id }}
        run: |
          set -e
          DIST_ID=""
          ORIGIN_DOMAIN="${WEB_BUCKET}.s3.${AWS_REGION}.amazonaws.com"
          COMMENT="HUNTECH Web CDN for ${WEB_BUCKET}"

          # 1) Explicit input from the run dialog
          if [ -n "${DIST_ID_INPUT}" ]; then
            DIST_ID="${DIST_ID_INPUT}"
          fi

          # 2) Try to find an existing distribution by comment and origin
          if [ -z "$DIST_ID" ]; then
            DIST_ID=$(aws cloudfront list-distributions \
              --query "DistributionList.Items[?Comment=='${COMMENT}' && contains(Origins.Items[].DomainName, '${ORIGIN_DOMAIN}')].Id | [0]" \
              --output text 2>/dev/null || true)
            [ "$DIST_ID" = "None" ] && DIST_ID=""
          fi

          # 3) Create distribution if still not found
          if [ -z "$DIST_ID" ]; then
            echo "Creating distribution..."
            CALLER_REF="huntech-$(date +%s)"
            DIST_CFG=$(jq -n \
              --arg ref "$CALLER_REF" \
              --arg comment "$COMMENT" \
              --arg origin "$ORIGIN_DOMAIN" \
              --arg oac "$OAC_ID" \
              '{
                CallerReference:$ref, Comment:$comment, Enabled:true,
                Origins:{ Quantity:1, Items:[{
                  Id:"S3Origin", DomainName:$origin,
                  S3OriginConfig:{ OriginAccessIdentity:"" },
                  OriginAccessControlId:$oac
                }]},
                DefaultCacheBehavior:{
                  TargetOriginId:"S3Origin",
                  ViewerProtocolPolicy:"redirect-to-https",
                  AllowedMethods:{Quantity:2,Items:["GET","HEAD"]},
                  Compress:true,
                  CachePolicyId:"658327ea-f89d-4fab-a63d-7e88639e58f6"
                },
                DefaultRootObject:"index.html",
                PriceClass:"PriceClass_100",
                HttpVersion:"http2"
              }')
            DIST_ID=$(aws cloudfront create-distribution \
              --distribution-config "$DIST_CFG" \
              --query "Distribution.Id" --output text)
            echo "Created distribution: $DIST_ID"
          else
            echo "Using distribution: $DIST_ID"
          fi

          echo "DIST_ID=$DIST_ID" >> $GITHUB_ENV

      - name: Wait until distribution is Deployed & fetch domain
        run: |
          set -e
          for i in $(seq 1 90); do
            DNS=$(aws cloudfront get-distribution --id "${DIST_ID}" --query "Distribution.DomainName" --output text 2>/dev/null || true)
            ST=$(aws cloudfront get-distribution --id "${DIST_ID}" --query "Distribution.Status" --output text 2>/dev/null || true)
            if [ -n "$DNS" ] && [ "$DNS" != "None" ]; then
              echo "Distribution: $DNS  Status: $ST"
              if [ "$ST" = "Deployed" ]; then
                echo "DIST_DNS=$DNS" >> $GITHUB_ENV
                break
              fi
            else
              echo "Waiting for distribution visibility... ($i/90)"
            fi
            sleep 7
          done
          [ -z "${DIST_DNS:-}" ] && { echo "Distribution not Deployed in time"; exit 1; }

      - name: Apply S3 bucket policy (allow only this distribution)
        run: |
          set -e
          POLICY=$(jq -n --arg bucket "$WEB_BUCKET" --arg acct "$ACCOUNT_ID" --arg dist "$DIST_ID" '{
            Version:"2012-10-17",
            Statement:[{
              Sid:"AllowCloudFrontServicePrincipalReadOnly",
              Effect:"Allow",
              Principal:{Service:"cloudfront.amazonaws.com"},
              Action:"s3:GetObject",
              Resource:("arn:aws:s3:::"+$bucket+"/*"),
              Condition:{StringEquals:{"AWS:SourceArn":("arn:aws:cloudfront::"+$acct+":distribution/"+$dist)}}
            }]
          }')
          printf '%s' "$POLICY" > /tmp/policy.json
          aws s3api put-bucket-policy --bucket "${WEB_BUCKET}" --policy file:///tmp/policy.json

      - name: Request ACM certificate in us-east-1 (required by CloudFront)
        id: cert
        run: |
          set -e
          CERT_ARN=$(aws acm request-certificate \
            --region us-east-1 \
            --domain-name "${CORE_FQDN}" \
            --validation-method DNS \
            --query CertificateArn --output text)
          echo "CERT_ARN=$CERT_ARN" >> $GITHUB_ENV
          echo "Requested cert: $CERT_ARN"
          # Create DNS validation CNAME
          REC=$(aws acm describe-certificate --region us-east-1 --certificate-arn "${CERT_ARN}" \
            --query "Certificate.DomainValidationOptions[0].ResourceRecord")
          NAME=$(echo "$REC" | jq -r .Name); TYPE=$(echo "$REC" | jq -r .Type); VALUE=$(echo "$REC" | jq -r .Value)
          [ -z "$NAME" -o "$NAME" = "null" ] && { echo "Validation record not found"; exit 1; }
          CHG=$(jq -n --arg n "$NAME" --arg t "$TYPE" --arg v "$VALUE" \
            '{Comment:"ACM DNS validation",Changes:[{Action:"UPSERT",ResourceRecordSet:{Name:$n,Type:$t,TTL:60,ResourceRecords:[{Value:$v}]}}]}')
          aws route53 change-resource-record-sets --hosted-zone-id "${HZ_ID}" --change-batch "$CHG" >/dev/null
          echo "Validation CNAME upserted: $NAME -> $VALUE"

      - name: Wait for certificate ISSUED
        run: |
          set -e
          for i in $(seq 1 60); do
            ST=$(aws acm describe-certificate --region us-east-1 --certificate-arn "${CERT_ARN}" \
              --query "Certificate.Status" --output text)
            echo "Cert status: $ST"
            [ "$ST" = "ISSUED" ] && exit 0
            sleep 10
          done
          echo "Certificate not issued in time"; exit 1

      - name: Attach alias + certificate to CloudFront
        run: |
          set -e
          CFG=$(aws cloudfront get-distribution-config --id "${DIST_ID}")
          ETAG=$(echo "$CFG" | jq -r .ETag)
          DC=$(echo "$CFG" | jq -r '.DistributionConfig')
          NEW=$(echo "$DC" | jq --arg dom "${CORE_FQDN}" --arg arn "${CERT_ARN}" '
            .Aliases.Items = ((.Aliases.Items // []) + [$dom] | unique) |
            .Aliases.Quantity = (.Aliases.Items | length) |
            .ViewerCertificate = {
              "ACMCertificateArn": $arn,
              "SSLSupportMethod": "sni-only",
              "MinimumProtocolVersion": "TLSv1.2_2021"
            }')
          printf '%s' "$NEW" > /tmp/cf.json
          aws cloudfront update-distribution --id "${DIST_ID}" --if-match "${ETAG}" \
            --distribution-config file:///tmp/cf.json >/dev/null
          echo "Distribution updated with alias + cert"

      - name: Create Route53 A/AAAA ALIAS → CloudFront
        run: |
          set -e
          CHG=$(jq -n --arg fqdn "$CORE_FQDN" --arg z "$CLOUDFRONT_ZONE_ID" --arg target "$DIST_DNS" \
            '{Comment:"Map domain to CloudFront",
              Changes:[
                {Action:"UPSERT",ResourceRecordSet:{Name:$fqdn,Type:"A",AliasTarget:{HostedZoneId:$z,DNSName:$target,EvaluateTargetHealth:false}}},
                {Action:"UPSERT",ResourceRecordSet:{Name:$fqdn,Type:"AAAA",AliasTarget:{HostedZoneId:$z,DNSName:$target,EvaluateTargetHealth:false}}}
              ]}')
          aws route53 change-resource-record-sets --hosted-zone-id "${HZ_ID}" --change-batch "$CHG" >/dev/null
          echo "Alias A/AAAA created for ${CORE_FQDN} → ${DIST_DNS}"

      - name: Invalidate and probe
        run: |
          set -e
          aws cloudfront create-invalidation --distribution-id "${DIST_ID}" --paths "/*" >/dev/null
          URL="https://${CORE_FQDN}/"
          echo "Visiting: $URL"
          for i in $(seq 1 24); do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            echo "Attempt $i -> $CODE"
            [ "$CODE" = "200" ] && { echo "domain ok: $URL"; exit 0; }
            sleep 5
          done
          echo "Site not reachable yet"; exit 1
