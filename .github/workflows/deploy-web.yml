name: HUNTECH Web Deploy (build + upload + fix + probe)

on:
  workflow_dispatch:
    inputs:
      dist_input:
        description: "CloudFront Distribution ID (E...) OR Domain (dxxxxx.cloudfront.net). Leave blank to auto-discover from core.huntechusa.com"
        required: false
        default: ""
      app_path:
        description: "Path to frontend project (where package.json lives)"
        required: false
        default: "."
      build_dir:
        description: "Optional: build output directory (e.g., dist, build, out). Leave blank to auto-detect"
        required: false
        default: ""

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: us-east-1
      ROLE_TO_ASSUME: arn:aws:iam::382773571217:role/HUNTECH-CICD
      WEB_BUCKET: huntech-web-382773571217-us-east-1-core
      SITE_FQDN: core.huntechusa.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install tools
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq dnsutils curl

      # ---------- Resolve distribution ----------
      - name: Resolve Dist ID (input → domain → CNAME of site)
        id: dist
        env:
          DIST_INPUT: ${{ github.event.inputs.dist_input }}
        run: |
          set -e
          DIST_ID=""
          DIST_DOMAIN=""

          # 1) Input provided
          if [ -n "${DIST_INPUT}" ]; then
            if echo "${DIST_INPUT}" | grep -qiE '\.cloudfront\.net$'; then
              DIST_DOMAIN="${DIST_INPUT}"
              DIST_ID=$(aws cloudfront list-distributions \
                --query "DistributionList.Items[?DomainName=='${DIST_DOMAIN}'].Id | [0]" \
                --output text 2>/dev/null || true)
            else
              DIST_ID="${DIST_INPUT}"
              DIST_DOMAIN=$(aws cloudfront get-distribution --id "${DIST_ID}" \
                --query "Distribution.DomainName" --output text 2>/dev/null || true)
            fi
          fi

          # 2) Discover via site's CNAME
          if [ -z "$DIST_ID" ] || [ "$DIST_ID" = "None" ]; then
            CF_CNAME=$(dig +short CNAME "${SITE_FQDN}" | sed 's/\.$//' || true)
            if [ -n "$CF_CNAME" ]; then
              DIST_DOMAIN="$CF_CNAME"
              DIST_ID=$(aws cloudfront list-distributions \
                --query "DistributionList.Items[?DomainName=='${DIST_DOMAIN}'].Id | [0]" \
                --output text 2>/dev/null || true)
            fi
          fi

          # 3) Fallback: any dist whose origin is this bucket
          if [ -z "$DIST_ID" ] || [ "$DIST_ID" = "None" ]; then
            ORIGIN="${WEB_BUCKET}.s3.${AWS_REGION}.amazonaws.com"
            DIST_ID=$(aws cloudfront list-distributions \
              --query "DistributionList.Items[?contains(Origins.Items[].DomainName, '${ORIGIN}')].Id | [0]" \
              --output text 2>/dev/null || true)
            [ "$DIST_ID" != "None" ] && DIST_DOMAIN=$(aws cloudfront get-distribution --id "${DIST_ID}" \
              --query "Distribution.DomainName" --output text 2>/dev/null || true)
          fi

          if [ -z "$DIST_ID" ] || [ "$DIST_ID" = "None" ]; then
            echo "ERROR: Could not resolve a CloudFront distribution. Provide dist_input or ensure DNS CNAME exists."
            exit 1
          fi

          echo "DIST_ID=$DIST_ID" >> $GITHUB_ENV
          echo "DIST_DOMAIN=$DIST_DOMAIN" >> $GITHUB_ENV
          echo "Using Distribution: $DIST_ID ($DIST_DOMAIN)"

      # ---------- Build frontend (auto-detect) ----------
      - name: Build (auto-detect package manager)
        working-directory: ${{ github.event.inputs.app_path }}
        run: |
          set -e
          if [ -f package.json ]; then
            if command -v pnpm >/dev/null 2>&1; then PM=pnpm; elif command -v yarn >/dev/null 2>&1; then PM=yarn; else PM=npm; fi
            case "$PM" in
              pnpm) pnpm install --frozen-lockfile || pnpm install; pnpm run build || pnpm build || true ;;
              yarn) yarn install --frozen-lockfile || yarn install; yarn build || true ;;
              npm)  npm ci || npm install; npm run build || true ;;
            esac
          else
            echo "No package.json found in $PWD; will deploy a static index.html if no build_dir provided."
          fi

      - name: Resolve build directory (auto-detect if not provided)
        id: outdir
        working-directory: ${{ github.event.inputs.app_path }}
        env:
          BUILD_DIR_IN: ${{ github.event.inputs.build_dir }}
        run: |
          set -e
          # If provided, use it relative to app_path
          if [ -n "$BUILD_DIR_IN" ] && [ -d "$BUILD_DIR_IN" ]; then
            OUT="$BUILD_DIR_IN"
          else
            for d in dist build out public; do
              if [ -d "$d" ]; then OUT="$d"; break; fi
            done
          fi
          if [ -z "$OUT" ]; then
            echo "No build output found; will deploy a known-good index.html to bucket root."
          else
            echo "Using build directory: $OUT"
          fi
          echo "OUT_DIR=${OUT:-}" >> $GITHUB_ENV

      # ---------- Ensure index at bucket root ----------
      - name: Upload site to S3
        working-directory: ${{ github.event.inputs.app_path }}
        run: |
          set -e
          if [ -n "${OUT_DIR:-}" ]; then
            aws s3 sync "${OUT_DIR}/" "s3://${WEB_BUCKET}/" --delete --cache-control max-age=60
          else
            mkdir -p _tmp_site
            printf '%s\n' '<!doctype html><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HUNTΞCH — Core</title><body style="font-family:system-ui;background:#111;color:#fff;padding:3rem"><h1>HUNTΞCH — Core</h1><p>CloudFront + OAC + private S3 is working.</p></body>' > _tmp_site/index.html
            aws s3 sync _tmp_site/ "s3://${WEB_BUCKET}/" --delete --cache-control max-age=60
          fi

      # ---------- Self-heal origin & bucket policy ----------
      - name: Ensure Default Root Object is index.html
        run: |
          set -e
          CFG=$(aws cloudfront get-distribution-config --id "${DIST_ID}")
          ETAG=$(echo "$CFG" | jq -r .ETag)
          DC=$(echo "$CFG" | jq -r '.DistributionConfig')
          ROOT=$(echo "$DC" | jq -r '.DefaultRootObject // empty')
          if [ "$ROOT" != "index.html" ]; then
            NEW=$(echo "$DC" | jq '.DefaultRootObject = "index.html"')
            printf '%s' "$NEW" > /tmp/new-cf.json
            aws cloudfront update-distribution --id "${DIST_ID}" --if-match "${ETAG}" \
              --distribution-config file:///tmp/new-cf.json >/dev/null
            echo "Set DefaultRootObject=index.html"
          else
            echo "DefaultRootObject already index.html"
          fi

      - name: Re-apply OAC bucket policy for this distribution
        run: |
          set -e
          cat > /tmp/policy.json <<EOF
{
  "Version": "2012-10-17",
  "Statement": [{
    "Sid": "AllowCloudFrontServicePrincipalReadOnly",
    "Effect": "Allow",
    "Principal": { "Service": "cloudfront.amazonaws.com" },
    "Action": "s3:GetObject",
    "Resource": "arn:aws:s3:::${WEB_BUCKET}/*",
    "Condition": {
      "StringEquals": {
        "AWS:SourceArn": "arn:aws:cloudfront::382773571217:distribution/${DIST_ID}"
      }
    }
  }]
}
EOF
          aws s3api put-bucket-policy --bucket "${WEB_BUCKET}" --policy file:///tmp/policy.json
          echo "Bucket policy applied for ${DIST_ID}"

      # ---------- Invalidate & probe ----------
      - name: Invalidate CloudFront
        run: |
          set -e
          aws cloudfront create-invalidation --distribution-id "${DIST_ID}" --paths "/*" >/dev/null
          echo "Invalidation created"

      - name: Probe /index.html (expect 200)
        run: |
          set -e
          URL="https://${{ env.SITE_FQDN }}/index.html"
          for i in $(seq 1 48); do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            echo "GET $URL -> $CODE (try $i/48)"
            [ "$CODE" = "200" ] && exit 0
            sleep 5
          done
          echo "index.html did not return 200 yet"; exit 1

      - name: Probe / (expect 200)
        if: ${{ success() }}
        run: |
          set -e
          URL="https://${{ env.SITE_FQDN }}/"
          for i in $(seq 1 48); do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            echo "GET $URL -> $CODE (try $i/48)"
            [ "$CODE" = "200" ] && { echo "domain ok: $URL"; exit 0; }
            sleep 5
          done
          echo "Root not 200 yet; give the edges a minute and refresh"
