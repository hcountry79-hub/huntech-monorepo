name: HUNTECH Map Domain (core.huntechusa.com → CloudFront)

on:
  workflow_dispatch:

jobs:
  mapdomain:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: us-east-1
      ROLE_TO_ASSUME: arn:aws:iam::382773571217:role/HUNTECH-CICD
      CDN_STACK: HUNTECH-WebCore-CDN
      CORE_FQDN: core.huntechusa.com
      APEX_DOMAIN: huntechusa.com
      CLOUDFRONT_ZONE_ID: Z2FDTNDATAQYW2

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure jq
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

      - name: Read CloudFront outputs (DistributionId + Domain)
        id: cfn
        shell: bash
        run: |
          set -e
          DIST_ID=$(aws cloudformation describe-stacks --stack-name "${CDN_STACK}" \
            --query "Stacks[0].Outputs[?OutputKey=='DistributionId'].OutputValue" --output text)
          DIST_DNS=$(aws cloudformation describe-stacks --stack-name "${CDN_STACK}" \
            --query "Stacks[0].Outputs[?OutputKey=='DistributionDomainName'].OutputValue" --output text)
          [ -z "$DIST_ID" -o "$DIST_ID" = "None" ] && { echo "No CDN stack outputs found"; exit 1; }
          echo "DIST_ID=$DIST_ID" >> $GITHUB_ENV
          echo "DIST_DNS=$DIST_DNS" >> $GITHUB_ENV
          echo "CDN: $DIST_ID  $DIST_DNS"

      - name: Resolve Hosted Zone for apex domain
        id: hz
        shell: bash
        run: |
          set -e
          HZ_ID=$(aws route53 list-hosted-zones-by-name --dns-name "${APEX_DOMAIN}" \
            --query "HostedZones[?Name=='${APEX_DOMAIN}.'].Id" --output text | sed 's#/hostedzone/##')
          [ -z "$HZ_ID" -o "$HZ_ID" = "None" ] && { echo "Hosted zone ${APEX_DOMAIN} not found"; exit 1; }
          echo "HZ_ID=$HZ_ID" >> $GITHUB_ENV
          echo "HostedZoneId: $HZ_ID"

      - name: Request ACM certificate (DNS validation, us-east-1)
        id: cert
        shell: bash
        run: |
          set -e
          CERT_ARN=$(aws acm request-certificate \
            --region us-east-1 \
            --domain-name "${CORE_FQDN}" \
            --validation-method DNS \
            --query CertificateArn --output text)
          echo "CERT_ARN=$CERT_ARN" >> $GITHUB_ENV
          echo "Requested cert: $CERT_ARN"

      - name: Create DNS validation CNAME in Route53
        shell: bash
        run: |
          set -e
          REC=$(aws acm describe-certificate --region us-east-1 --certificate-arn "${CERT_ARN}" \
            --query "Certificate.DomainValidationOptions[0].ResourceRecord")
          NAME=$(echo "$REC" | jq -r .Name)
          TYPE=$(echo "$REC" | jq -r .Type)
          VALUE=$(echo "$REC" | jq -r .Value)
          [ -z "$NAME" -o "$NAME" = "null" ] && { echo "Validation record not found"; exit 1; }

          CHG=$(jq -n --arg n "$NAME" --arg t "$TYPE" --arg v "$VALUE" \
            '{Comment:"ACM DNS validation",Changes:[{Action:"UPSERT",ResourceRecordSet:{Name:$n,Type:$t,TTL:60,ResourceRecords:[{Value:$v}]}}]}')

          aws route53 change-resource-record-sets \
            --hosted-zone-id "${HZ_ID}" \
            --change-batch "$CHG" >/dev/null
          echo "Upserted validation CNAME: $NAME -> $VALUE"

      - name: Wait for certificate to be ISSUED
        shell: bash
        run: |
          set -e
          for i in $(seq 1 60); do
            ST=$(aws acm describe-certificate --region us-east-1 --certificate-arn "${CERT_ARN}" \
              --query "Certificate.Status" --output text)
            echo "Cert status: $ST"
            [ "$ST" = "ISSUED" ] && exit 0
            sleep 10
          done
          echo "Certificate not issued in time"; exit 1

      - name: Attach alias + certificate to CloudFront
        shell: bash
        run: |
          set -e
          CFG=$(aws cloudfront get-distribution-config --id "${DIST_ID}")
          ETAG=$(echo "$CFG" | jq -r .ETag)
          DC=$(echo "$CFG" | jq -r '.DistributionConfig')

          NEW=$(echo "$DC" | \
            jq --arg dom "${CORE_FQDN}" --arg arn "${CERT_ARN}" '
              .Aliases.Items = ((.Aliases.Items // []) + [$dom] | unique) |
              .Aliases.Quantity = (.Aliases.Items | length) |
              .ViewerCertificate = {
                "ACMCertificateArn": $arn,
                "SSLSupportMethod": "sni-only",
                "MinimumProtocolVersion": "TLSv1.2_2021"
              }')

          printf '%s' "$NEW" > /tmp/cf.json

          aws cloudfront update-distribution \
            --id "${DIST_ID}" \
            --if-match "${ETAG}" \
            --distribution-config file:///tmp/cf.json >/dev/null

          echo "Updated distribution with alias + cert"

      - name: Create Route53 A/AAAA ALIAS records
        shell: bash
        run: |
          set -e
          CHG=$(jq -n \
            --arg fqdn "$CORE_FQDN" \
            --arg z "$CLOUDFRONT_ZONE_ID" \
            --arg target "$DIST_DNS" \
            '{
              Comment:"Map domain to CloudFront",
              Changes:[
                {Action:"UPSERT",ResourceRecordSet:{Name:$fqdn,Type:"A",AliasTarget:{HostedZoneId:$z,DNSName:$target,EvaluateTargetHealth:false}}},
                {Action:"UPSERT",ResourceRecordSet:{Name:$fqdn,Type:"AAAA",AliasTarget:{HostedZoneId:$z,DNSName:$target,EvaluateTargetHealth:false}}}
              ]
            }')
          aws route53 change-resource-record-sets --hosted-zone-id "${HZ_ID}" --change-batch "$CHG" >/dev/null
          echo "A/AAAA alias created for ${CORE_FQDN} → ${DIST_DNS}"

      - name: Invalidate and probe
        shell: bash
        run: |
          set -e
          aws cloudfront create-invalidation --distribution-id "${DIST_ID}" --paths "/*" >/dev/null
          URL="https://${CORE_FQDN}/"
          echo "Visiting: $URL"
          for i in $(seq 1 24); do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            echo "Attempt $i -> $CODE"
            [ "$CODE" = "200" ] && { echo "domain ok: $URL"; exit 0; }
            sleep 5
          done
          echo "Site not reachable yet"; exit 1
